<#
.SYNOPSIS
  Orchestrator: Run all backfill phases and call Backfill-FullMarket worker.
.DESCRIPTION
  - Orchestrates Phase-1 backfill and monitoring. Calls tools\Backfill-FullMarket.ps1 as a worker process.
  - Enforces ALPHACITY_ALLOW == '1' (代號六 policy) before any destructive action.
  - Runs preflight before/after worker; collects worker stdout/stderr and summary JSON and writes a run-level summary.
  - Logs are placed under reports/.
#>

param(
  [string]$RootPath = 'C:\AI\tw-alpha-stack',
  [int]   $Batch    = 400,
  [int]   $MaxRetries = 6,
  [switch]$FillGaps,
  [switch]$Force,
  [switch]$Verbose,
  [switch]$FailFast,
  [string]$End = ''    # 可選：覆寫 expect_date（--end 不含），僅用於內部 preflight 期望日
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
Set-Location $RootPath

# Safety: enforce ALPHACITY_ALLOW per 代號六
if (-not $env:ALPHACITY_ALLOW -or $env:ALPHACITY_ALLOW -ne '1') {
  Write-Error "ALPHACITY_ALLOW != 1. Aborting to honor 代號六 policy. Set env var and retry."
  exit 1
}

# logging helper
$ts    = (Get-Date).ToString('yyyyMMdd_HHmmss')
$runLog = Join-Path $RootPath ("reports\run_backfill_all_$ts.log")
function RunLog([string]$m) {
  $line = "[{0}] {1}" -f (Get-Date).ToString('s'), $m
  $line | Tee-Object -FilePath $runLog -Append | Out-Null
  if ($Verbose) { Write-Host $line }
}

RunLog "Starting Run-Backfill-All (Batch=$Batch; FillGaps=$($FillGaps.IsPresent); Force=$($Force.IsPresent))"

# Ensure worker and python exist
$workerPath = Join-Path $RootPath 'tools\Backfill-FullMarket.ps1'
if (-not (Test-Path $workerPath)) { RunLog "Worker not found: $workerPath"; exit 2 }
$PY = '.\.venv\Scripts\python.exe'
if (-not (Test-Path $PY))       { RunLog "Python not found at $PY"; exit 3 }

# 1) preflight BEFORE
RunLog "RUN preflight_check.py (before)"
& $PY .\scripts\preflight_check.py --rules .\rules.yaml --export .\reports --root . 2>&1 | Tee-Object -FilePath $runLog -Append | Out-Null

$pf_before_raw = Get-Content .\reports\preflight_report.json -Raw
try { $pf_before = $pf_before_raw | ConvertFrom-Json } catch { RunLog "Cannot parse preflight_report.json (before)"; $pf_before = $null }

$expect_date = $null
if ($pf_before -and $pf_before.meta -and $pf_before.meta.expect_date) { $expect_date = $pf_before.meta.expect_date }
elseif ($pf_before -and $pf_before.expect_date) { $expect_date = $pf_before.expect_date }
if ($End) { $expect_date = $End }
if (-not $expect_date) { RunLog "Cannot determine expect_date. Aborting."; exit 4 }
RunLog "Using expect_date = $expect_date"
RunLog ("PREFLIGHT BEFORE -> prices={0} chip={1} per={2} dividend={3}" -f `
         $pf_before.freshness.prices.max_date, `
         $pf_before.freshness.chip.max_date, `
         $pf_before.freshness.per.max_date, `
         $pf_before.freshness.dividend.max_date)

# 2) CALL worker (正確的啟動寫法；不使用 .StandardOutput 讀流)
$workerStdout = Join-Path $RootPath ("reports\backfill_worker_stdout_$ts.log")
$workerStderr = Join-Path $RootPath ("reports\backfill_worker_stderr_$ts.log")

# 以 -File 方式避免引號地獄
$argList = @(
  '-NoProfile','-NonInteractive','-ExecutionPolicy','Bypass',
  '-File', $workerPath,
  '-RootPath', $RootPath,
  '-Batch', "$Batch"
)
if ($FillGaps) { $argList += '-FillGaps' }
if ($Force)    { $argList += '-Force' }
if ($Verbose)  { $argList += '-Verbose' }

RunLog ("Calling worker: pwsh " + ($argList -join ' '))

$proc = Start-Process -FilePath 'pwsh' -ArgumentList $argList `
         -Wait -PassThru -NoNewWindow `
         -RedirectStandardOutput $workerStdout `
         -RedirectStandardError  $workerStderr

$exitCode = $proc.ExitCode
RunLog "Worker exit code = $exitCode. Stdout -> $(Split-Path $workerStdout -Leaf); Stderr -> $(Split-Path $workerStderr -Leaf)"

# 3) collect worker summary
$workerSummaryFile = Get-ChildItem -Path (Join-Path $RootPath 'reports') -Filter 'backfill_summary_*.json' | Sort-Object LastWriteTime -Descending | Select-Object -First 1
$workerSummary = $null
if ($workerSummaryFile) {
  RunLog "Found worker summary: $($workerSummaryFile.Name)"
  try { $workerSummary = Get-Content $workerSummaryFile.FullName -Raw | ConvertFrom-Json }
  catch { RunLog "Failed to parse worker summary json" }
} else {
  RunLog "No worker summary json found under reports/"
}

# Run-level summary
$runSummary = [ordered]@{
  run_ts         = $ts
  expect_date    = $expect_date
  worker_exit    = $exitCode
  worker_stdout  = (Split-Path $workerStdout -Leaf)
  worker_stderr  = (Split-Path $workerStderr -Leaf)
  pf_before      = $pf_before
  worker_summary = $workerSummary
}
$runSummaryFile = Join-Path $RootPath ("reports\backfill_summary_run_$ts.json")
$runSummary | ConvertTo-Json -Depth 10 | Out-File -FilePath $runSummaryFile -Encoding utf8
RunLog "Wrote run summary to $(Split-Path $runSummaryFile -Leaf)"

if ($exitCode -ne 0) {
  RunLog "Worker exited with non-zero exit code $exitCode"
  if ($FailFast) { RunLog "FailFast set. Exiting with worker exit code."; exit $exitCode }
}

# 4) preflight AFTER
RunLog "RUN final preflight_check.py (after)"
& $PY .\scripts\preflight_check.py --rules .\rules.yaml --export .\reports --root . 2>&1 | Tee-Object -FilePath $runLog -Append | Out-Null

$pf_after_raw = Get-Content .\reports\preflight_report.json -Raw
try { $pf_after = $pf_after_raw | ConvertFrom-Json } catch { RunLog "Cannot parse preflight_report.json (after)"; $pf_after = $null }

RunLog ("PREFLIGHT AFTER  -> prices={0} chip={1} per={2} dividend={3}" -f `
         $pf_after.freshness.prices.max_date, `
         $pf_after.freshness.chip.max_date, `
         $pf_after.freshness.per.max_date, `
         $pf_after.freshness.dividend.max_date)

RunLog "Run-Backfill-All DONE"
if ($exitCode -ne 0) { exit $exitCode } else { exit 0 }
