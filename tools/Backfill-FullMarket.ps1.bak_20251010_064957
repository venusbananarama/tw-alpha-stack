[CmdletBinding()]
param(
  [string]$RootPath = "C:\AI\tw-alpha-stack",
  [string]$Start    = "",     # 不含 End；留空則用 preflight 推估
  [string]$End      = "",     # 不含 End；留空則用 preflight 推估
  [int]   $Batch    = 400,    # 投資池切批尺寸（用在 chip/per）
  [int]   $MaxRetries = 6,
  [int]   $Workers  = 4,      # 傳遞給 python 的 --workers（若支援）
  [switch]$FillGaps,          # 缺口補齊
  [switch]$Force,             # 跳過 gating 強制重打
  [switch]$Verbose
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
Set-Location $RootPath

# --- KILLSWITCH（代號六/allow=1） ---
if (-not $env:ALPHACITY_ALLOW -or $env:ALPHACITY_ALLOW -ne '1') {
  throw "ALPHACITY_ALLOW != 1（請先：`$env:ALPHACITY_ALLOW='1'`）"
}

# --- Python 驅動 ---
$PY = '.\.venv\Scripts\python.exe'
if (-not (Test-Path $PY)) { throw "Python not found at $PY" }

# --- FinMind 端點與 token 檢查 ---
$base = if ($env:FINMIND_BASE_URL) { $env:FINMIND_BASE_URL.Trim() } else { 'https://api.finmindtrade.com/api/v4/data' }
if (-not $env:FINMIND_TOKEN) { throw "FINMIND_TOKEN not set" }

# --- Dataset 對照表（PowerShell 名稱 → FinMind dataset 名稱） ---
$Map = @{
  'prices'   = 'TaiwanStockPrice'
  'chip'     = 'TaiwanStockInstitutionalInvestorsBuySell'
  'dividend' = 'TaiwanStockDividend'
  'per'      = 'TaiwanStockPER'
}

# --- Log/摘要 ---
$ts   = Get-Date -Format 'yyyyMMdd_HHmmss'
$repo = Join-Path $RootPath 'reports'
New-Item -ItemType Directory -Force -Path $repo | Out-Null
$log  = Join-Path $repo ("backfill_worker_$ts.log")

function Log([string]$m){
  $line = "[{0}] {1}" -f (Get-Date).ToString('s'), $m
  $line | Tee-Object -FilePath $log -Append | Out-Null
  if ($Verbose){ Write-Host $line }
}

# --- 讀 preflight，推估日期窗 ---
& $PY .\scripts\preflight_check.py --rules .\rules.yaml --export .\reports --root . *>$null
$pf = $null
try { $pf = Get-Content .\reports\preflight_report.json -Raw | ConvertFrom-Json } catch {}
$expect = $null
if ($pf) {
  if ($pf.meta -and $pf.meta.expect_date) { $expect = $pf.meta.expect_date }
  elseif ($pf.expect_date) { $expect = $pf.expect_date }
}

# 缺省日窗：從各 dataset 的 max_date+1 補到 expect（End 不含）
function Get-DefaultWindow([string]$maxDate,[string]$expectDate){
  if (-not $maxDate -or -not $expectDate) { return $null }
  $d0 = [DateTime]::Parse($maxDate).AddDays(1).ToString('yyyy-MM-dd')
  $d1 = [DateTime]::Parse($expectDate).ToString('yyyy-MM-dd')
  return @{ start=$d0; end=$d1 }
}

# --- 讀投資池（用於 chip/per 切批） ---
$universeFile = Join-Path $RootPath 'configs\investable_universe.txt'
$POOL = @()
if (Test-Path $universeFile) {
  $POOL = (Get-Content $universeFile | Where-Object { $_ -and -not $_.StartsWith('#') } )
  # 規範：2330.TW → 2330（手冊口徑）
  $POOL = $POOL | ForEach-Object { $_ -replace '\.TW$','' }
  Log ("Universe loaded: {0} symbols" -f $POOL.Count)
} else {
  Log "Universe file not found, will run prices/dividend whole-market only (if script supports)."
}

# --- 工具：執行一次 dataset 回補 ---
function Invoke-Backfill([string]$dname,[string]$start,[string]$end,[string[]]$symbols,[int]$retryMax){
  $table  = $Map[$dname]
  if (-not $table) { Log ("SKIP {0}: unknown dataset" -f $dname); return 0 }

  $args = @('.\scripts\finmind_backfill.py','--datasets', $table,
            '--start', $start, '--end', $end, '--datahub-root','datahub')

  if ($symbols -and $symbols.Count -gt 0) {
    $args += @('--symbols', ($symbols -join ','))
  }
  if ($Force)   { $args += '--force' }
  if ($Workers -gt 0) { $args += @('--workers', "$Workers") }

  $try=0; $ok=0
  while ($try -lt $retryMax) {
    $try++
    try {
      Log ("Run {0} try#{1}: {2}" -f $dname,$try, ($args -join ' '))
      & $PY @args *>&1 | Tee-Object -FilePath $log -Append | Out-Null
      $ok=1; break
    }
    catch {
      $msg = $_.Exception.Message
      Log ("Error({0}) {1}" -f $dname,$msg)
      if ($msg -match '402') {
        # 智慧等待到下一整點（與手冊一致）
        $now = Get-Date
        $wait = ([DateTime]::Today.AddHours($now.Hour+1) - $now).TotalSeconds
        $wait = [Math]::Min([int][Math]::Ceiling($wait), 3600)
        Log ("HTTP 402: wait {0}s until next hour" -f $wait)
        Start-Sleep -Seconds $wait
      } else {
        $backoff = (10,20,40,80,120)[[Math]::Min($try-1,4)]
        Start-Sleep -Seconds $backoff
      }
    }
  }
  return $ok
}

# --- 彙總（避免 "SKIP $dname: ..." 觸發冒號解析） ---
$summary = [ordered]@{}

# --- 計算各 dataset 的日窗 ---
$win_prices   = $null
$win_chip     = $null
$win_dividend = $null
$win_per      = $null

if ($Start -and $End) {
  $win_prices   = @{ start=$Start; end=$End }
  $win_chip     = @{ start=$Start; end=$End }
  $win_dividend = @{ start=$Start; end=$End }
  $win_per      = @{ start=$Start; end=$End }
} elseif ($pf -and $expect) {
  $win_prices   = Get-DefaultWindow $pf.freshness.prices.max_date   $expect
  $win_chip     = Get-DefaultWindow $pf.freshness.chip.max_date     $expect
  $win_dividend = Get-DefaultWindow $pf.freshness.dividend.max_date $expect
  $win_per      = Get-DefaultWindow $pf.freshness.per.max_date      $expect
} else {
  throw "無法決定回補日窗：請傳 -Start/-End 或先產生 preflight_report.json"
}

# --- FillGaps：只補缺口（由 py 腳本決定 gating；這裡只傳日窗） ---
function Run-One([string]$name,[hashtable]$win,[string[]]$syms){
  if (-not $win) {
    Log ("SKIP {0}: window=null" -f $name); $summary[$name] = @{ status='skip'; reason='window=null' }; return
  }
  $st = $win.start; $ed = $win.end

  # dataset 類型差異：prices/dividend 整市單發；chip/per 用投資池切批（手冊）
  $usePool = ($name -in @('chip','per')) -and ($POOL.Count -gt 0)
  if ($usePool) {
    $batch = [Math]::Max(1,$Batch)
    for ($i=0; $i -lt $POOL.Count; $i+=$batch) {
      $j=[Math]::Min($i+$batch-1,$POOL.Count-1)
      $chunk=$POOL[$i..$j]
      if ($PSBoundParameters.ContainsKey('Verbose')){ $VerbosePreference='Continue' }
      $ok = Invoke-Backfill $name $st $ed $chunk $MaxRetries
      if (-not $ok) { $summary[$name] = @{ status='fail'; batch="$i..$j" }; return }
    }
    $summary[$name] = @{ status='ok'; batches=[int][Math]::Ceiling($POOL.Count/$batch) }
  } else {
    $ok = Invoke-Backfill $name $st $ed @() $MaxRetries
    $summary[$name] = @{ status= ($ok ? 'ok':'fail') }
  }
}

Run-One 'prices'   $win_prices   $POOL
Run-One 'chip'     $win_chip     $POOL
Run-One 'per'      $win_per      $POOL
Run-One 'dividend' $win_dividend $POOL

# --- 寫出 summary（json） ---
$sumFile = Join-Path $repo ("backfill_summary_{0}.json" -f $ts)
($summary | ConvertTo-Json -Depth 10) | Set-Content -Path $sumFile -Encoding utf8
Log ("WROTE {0}" -f (Split-Path $sumFile -Leaf))
