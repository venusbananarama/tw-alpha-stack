<#
.SYNOPSIS
  Backfill full market (prices/chip/per/dividend) to preflight expect_date using configs/investable_universe.txt
.DESCRIPTION
  - 完全以 PowerShell 編寫（PowerShell 7.x）；不使用 bash heredoc 或 shell 重導語法，符合代號六要求。
  - 開頭強制檢查環境變數 ALPHACITY_ALLOW == '1'（若未設定則中止）。
  - 會先執行 preflight_check.py 取得 expect_date 與各 dataset freshness，然後針對未覆蓋的日窗按 batch 分批呼叫 finmind_backfill.py。
  - 內建 402/quota 偵測（遇到 402 會等待至下一整點再重試）與指數退避（exponential backoff）。
  - 產出日誌: reports/backfill_full_<ts>.log 與摘要: reports/backfill_summary_<ts>.json
#>

param(
  [string]$RootPath = 'C:\AI\tw-alpha-stack',
  [int]$Batch = 400,
  [int]$MaxRetries = 6,
  [switch]$FillGaps,
  [switch]$Force,
  [switch]$Verbose
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
Set-Location $RootPath

# Safety: enforce ALPHACITY_ALLOW per 代號六
if (-not $env:ALPHACITY_ALLOW -or $env:ALPHACITY_ALLOW -ne '1') {
  Write-Error "ALPHACITY_ALLOW != 1. Aborting to honor 代號六 policy. Set env var and retry."
  exit 1
}

# python executable (relative venv)
$PY = '.\.venv\Scripts\python.exe'
if (-not (Test-Path $PY)) {
  Write-Error "Python executable not found at $PY. Ensure virtualenv exists and path correct."; exit 2
}

# logging
$ts = (Get-Date).ToString('yyyyMMdd_HHmmss')
$logFile = Join-Path $RootPath ("reports\backfill_full_$ts.log")
$summaryFile = Join-Path $RootPath ("reports\backfill_summary_$ts.json")

function Log {
  param([string]$msg)
  $line = ("[{0}] {1}" -f (Get-Date).ToString('s'), $msg)
  $line | Tee-Object -FilePath $logFile -Append | Out-Null
  if ($Verbose) { Write-Host $line }
}

Log "Starting Backfill-FullMarket.ps1 (Batch=$Batch, MaxRetries=$MaxRetries, FillGaps=$($FillGaps.IsPresent), Force=$($Force.IsPresent))"

# run preflight to get expect_date / freshness
Log "RUN preflight_check.py to obtain expect_date and freshness"
& $PY .\scripts\preflight_check.py --rules .\rules.yaml --export .\reports --root . 2>&1 | Tee-Object -FilePath $logFile -Append | Out-Null

$pfRaw = Get-Content .\reports\preflight_report.json -Raw
try { $pf = $pfRaw | ConvertFrom-Json } catch { Write-Error "Cannot parse preflight_report.json"; exit 3 }

$expect_date = $null
if ($pf.meta -and $pf.meta.expect_date) { $expect_date = $pf.meta.expect_date } elseif ($pf.expect_date) { $expect_date = $pf.expect_date }
if (-not $expect_date) { Write-Error "expect_date not found in preflight report"; exit 4 }
Log "expect_date = $expect_date"

function NextDayOf { param($datestr) if (-not $datestr) { return $null } return ((Get-Date $datestr).AddDays(1)).ToString('yyyy-MM-dd') }
$start_prices = NextDayOf $pf.freshness.prices.max_date
$start_chip   = NextDayOf $pf.freshness.chip.max_date
$start_per    = NextDayOf $pf.freshness.per.max_date
$start_div    = NextDayOf $pf.freshness.dividend.max_date

Log "Dataset start dates: prices=$start_prices, chip=$start_chip, per=$start_per, dividend=$start_div"

# read investable_universe
$universeFile = Join-Path $RootPath 'configs\investable_universe.txt'
if (-not (Test-Path $universeFile)) { Write-Error "investable_universe.txt not found at $universeFile"; exit 5 }
$allsyms = Get-Content $universeFile | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | ForEach-Object { $_.Trim() }
if ($allsyms.Count -eq 0) { Write-Error "investable_universe.txt appears empty"; exit 6 }
Log "Universe symbols count = $($allsyms.Count)"

function Chunk($arr, $size) {
  $chunks = @()
  for ($i = 0; $i -lt $arr.Count; $i += $size) {
    $end = [Math]::Min($i + $size - 1, $arr.Count - 1)
    $chunks += ,($arr[$i..$end])
  }
  return $chunks
}

# backfill invocation with retry and 402 handling
function Invoke-Backfill {
  param(
    [string]$dataset,
    [string[]]$symbolsArray,
    [string]$start,
    [string]$end,
    [bool]$forceSwitch = $false
  )

  $symList = $symbolsArray -join ','
  $forceArg = $null
  if ($forceSwitch) { $forceArg = '--force' }

  $attempt = 0
  while ($attempt -le $MaxRetries) {
    $attempt++
    try {
      $args = @('.\scripts\finmind_backfill.py','--datasets',$dataset,'--symbols',$symList,'--start',$start,'--end',$end,'--datahub-root','datahub')
      if ($forceArg) { $args += $forceArg }
      Log "CALL: $($args -join ' ')"

      $procOutput = & $PY $args 2>&1
      $outText = ($procOutput -join "`n")
      $outText | Tee-Object -FilePath $logFile -Append | Out-Null

      # detect 402/quota
      if ($outText -match '(HTTP\s*402|\b402\b|quota|Quota)') {
        Log "Detected 402/quota. Waiting until next whole hour before retry..."
        $now = Get-Date
        # compute next whole hour timestamp (a few seconds buffer)
        $nextHour = $now.AddHours(1)
        $nextHour = Get-Date -Year $nextHour.Year -Month $nextHour.Month -Day $nextHour.Day -Hour $nextHour.Hour -Minute 0 -Second 5
        $sleepSec = ([datetime]$nextHour - $now).TotalSeconds
        Start-Sleep -Seconds [Math]::Ceiling($sleepSec)
        continue
      }

      # parse rows_written
      $m = [regex]::Match($outText, 'rows_written\s*[:=]?\s*(\d+)', 'IgnoreCase')
      if ($m.Success) { $rows = [int]$m.Groups[1].Value } else { $rows = 0 }

      return @{ok=$true; rows=$rows; out=$outText}
    } catch {
      $err = $_.Exception.Message
      Log "Backfill error attempt $attempt: $err"
      if ($attempt -gt $MaxRetries) { return @{ok=$false; err=$err; out=$outText} }
      $backoff = [Math]::Pow(2,$attempt) * 5
      Log "Sleeping $backoff seconds before retry..."
      Start-Sleep -Seconds $backoff
    }
  }
}

$summary = @{}
$datasets = @(
  @{name='TaiwanStockPrice'; start=$start_prices},
  @{name='TaiwanStockInstitutionalInvestorsBuySell'; start=$start_chip},
  @{name='TaiwanStockPER'; start=$start_per},
  @{name='TaiwanStockDividend'; start=$start_div}
)

foreach ($ds in $datasets) {
  $dname = $ds.name
  $dstart = $ds.start
  if (-not $dstart) {
    Log "SKIP $dname: start date is null (already up-to-date or missing)."
    $summary[$dname] = @{skipped=$true; rows=0}
    continue
  }

  Log "==== Dataset: $dname | start=$dstart end=$expect_date ===="

  $chunks = Chunk $allsyms $Batch
  $totalRows = 0
  $idx = 0
  foreach ($chunk in $chunks) {
    $idx++
    Log "Dataset $dname - Batch $idx / $($chunks.Count) -> symbols=$($chunk.Count)"

    $res = Invoke-Backfill -dataset $dname -symbolsArray $chunk -start $dstart -end $expect_date -forceSwitch:$Force.IsPresent
    if ($res.ok) {
      Log "Batch $idx finished: rows_written = $($res.rows)"
      $totalRows += $res.rows
    } else {
      Log "Batch $idx FAILED: $($res.err)"
      $summary["${dname}_error_batch_$idx"] = $res.err
    }

    Start-Sleep -Seconds 3
  }

  $summary[$dname] = @{skipped=$false; rows=$totalRows}
  Log "==== Finished dataset $dname -> total_rows = $totalRows ===="
}

# write summary
$summary | ConvertTo-Json -Depth 6 | Out-File -FilePath $summaryFile -Encoding utf8
Log "Backfill run finished. Summary written to $summaryFile"

# final preflight
Log "RUN final preflight_check.py for verification"
& $PY .\scripts\preflight_check.py --rules .\rules.yaml --export .\reports --root . 2>&1 | Tee-Object -FilePath $logFile -Append | Out-Null
$pf_after = Get-Content .\reports\preflight_report.json -Raw | ConvertFrom-Json
Log ("PREFLIGHT AFTER -> prices=$($pf_after.freshness.prices.max_date) chip=$($pf_after.freshness.chip.max_date) per=$($pf_after.freshness.per.max_date) dividend=$($pf_after.freshness.dividend.max_date)")

Log "DONE"
