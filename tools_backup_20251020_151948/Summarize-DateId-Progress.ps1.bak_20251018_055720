[CmdletBinding()]
param(
  [string]$ReportsDir = ".\reports",
  [string]$OutCsv     = ".\state\dateid_progress_history.csv",
  [string]$TagFilter  = ""   # 例如 S1_hist48；留空=全抓
)

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

# 收集所有 fullmarket log
$pat = if([string]::IsNullOrWhiteSpace($TagFilter)){
  'fullmarket_maxrate_*_*.log'
}else{
  "fullmarket_maxrate_${TagFilter}_*.log"
}
$logs = Get-ChildItem $ReportsDir -File -ErrorAction SilentlyContinue |
        Where-Object { $_.Name -like $pat } |
        Sort-Object LastWriteTime

if(-not $logs){ Write-Host "（找不到符合的 fullmarket log）"; exit 0 }

# 建 CSV 表頭
$csvHead = 'ts,log,idx,win_start,win_end,is_last_completed'
$dir = Split-Path -Parent $OutCsv
if(-not (Test-Path $dir)){ New-Item -ItemType Directory -Force -Path $dir | Out-Null }
Set-Content $OutCsv -Encoding UTF8 -Value $csvHead

[int]$totalWins = 0
[string]$lastCompletedEnd = ""
foreach($f in $logs){
  # 解析所有 header：=== YYYY-MM-DD -> YYYY-MM-DD ===
  $hdrs = Select-String -Path $f.FullName -Pattern '^===\s+(\d{4}-\d{2}-\d{2})\s+->\s+(\d{4}-\d{2}-\d{2})\s+==='
  if($hdrs.Count -eq 0){ continue }

  # 將每一個 header 轉成一列
  for($i=0; $i -lt $hdrs.Count; $i++){
    $m = $hdrs[$i].Matches
    $s = $m.Groups[1].Value
    $e = $m.Groups[2].Value
    $totalWins++
    # 預設不是「上一個完成窗」
    $isLastCompleted = 0
    # 如果後面還有下一個 header，代表這個窗已完成（下一個窗已開始）
    if($i -lt ($hdrs.Count-1)){
      $isLastCompleted = 1
      $lastCompletedEnd = $e
    }
    $line = '{0},{1},{2},{3},{4},{5}' -f `
            ($f.LastWriteTime.ToString('s')), ($f.Name -replace ',',';'), $totalWins, $s, $e, $isLastCompleted
    Add-Content -Path $OutCsv -Value $line
  }
}

Write-Host "=== 彙整完成 ===" -ForegroundColor Cyan
Write-Host ("已輸出：{0}" -f (Resolve-Path $OutCsv).Path)
Write-Host ("總視窗數：{0}" -f $totalWins)
if($lastCompletedEnd){
  Write-Host ("最後一個『完成』視窗的右端(last_end 候選)：{0}" -f $lastCompletedEnd) -ForegroundColor Yellow
}else{
  Write-Host "尚無完整完成窗（每份 log 只看到單一 header）。" -ForegroundColor Yellow
}
