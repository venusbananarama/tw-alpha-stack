# --- injected guard: results fallback + atexit exporter (v3) ---
from pathlib import Path as _P
import atexit as _atexit, json as _json

# 後備 results：若未賦值，避免 NameError
try:
    results  # noqa: F821
except NameError:
    results = None

def _ac_get_results():
    global results
    if results is None:
        # 最小可被 Gate 處理的結構；主程式若產出真實 results 會覆蓋它
        results = {"runs": [], "meta": {"mode": "core-fallback", "note": "auto-filled due to missing results"}}
    return results

def _ac_get_export_path():
    # 若主程式有定義 export_path 就用之，否則落到 ./reports/wf_results.json
    try:
        return export_path  # noqa: F821
    except Exception:
        return (_P.cwd() / "reports" / "wf_results.json")

def _ac_export():
    try:
        _p = _ac_get_export_path()
        _p.parent.mkdir(parents=True, exist_ok=True)
        _p.write_text(_json.dumps(_ac_get_results(), ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception:
        # 不要讓 atexit export 影響主程式退出
        pass

# 確保離開程式時一定會留下結果（即使主流程中途失敗）
_atexit.register(_ac_export)
# --- /injected guard ---
# --- injected guard: args fallback (v1) ---
import sys as _sys
try:
    args  # noqa: F821
except NameError:
    try:
        import argparse as _argparse
        _ap = _argparse.ArgumentParser(add_help=False)
        _ap.add_argument('--dir')
        _ap.add_argument('--export')
        _ap.add_argument('--root')
        _ap.add_argument('--config')
        _ap.add_argument('--pattern')
        _ap.add_argument('--runs', nargs='*')
        _ap.add_argument('--limit', type=int)
        _ap.add_argument('--workers', type=int)
        _ap.add_argument('--dryrun', action='store_true')
        _ap.add_argument('--verbose', action='store_true')
        args = _ap.parse_known_args()[0]
    except Exception:
        from types import SimpleNamespace as _NS
        args = _NS(dir='runs/wf_configs', export='reports', root='.', config=None, pattern=None, runs=None, limit=None, workers=None, dryrun=False, verbose=False)
globals()['args'] = args
# --- /injected guard: args fallback (v1) ---
# --- injected guard: run_path self-skip & safe str() ---
import runpy as _runpy
from pathlib import Path as _P
def _pstr(p):
    try:
        return str(p)
    except Exception:
        return p.as_posix() if hasattr(p,'as_posix') else repr(p)
_SELF = _P(__file__).resolve()
_orig_run_path = _runpy.run_path
def _guarded_run_path(p, *a, **kw):
    try:
        _pp = _P(p) if not hasattr(p,'resolve') else p
        if _pp.resolve() == _SELF:
            return None
        if not isinstance(p, (str, bytes)):
            p = _pstr(p)
    except Exception:
        try:
            p = _pstr(p)
        except Exception:
            pass
    return _orig_run_path(p, *a, **kw)
_runpy.run_path = _guarded_run_path
# --- /injected guard: run_path ---
import sys, runpy
from pathlib import Path

root = Path(__file__).resolve().parents[1]   # C:/AI/tw-alpha-stack
cands = [root / "scripts" / "wf_runner.py", Path("scripts") / "wf_runner.py"]
safe  = root / "scripts" / "wf_runner_safe.py"

def _try_run(p: Path) -> bool:
    try:
        sys.argv[0] = str(p)
        runpy.run_path(str(p), run_name="__main__")
        return True
    except (IndentationError, SyntaxError) as e:
        sys.stderr.write(f"[Bridge] {e.__class__.__name__} at {p}: {e}\n")
        return False

for p in cands:
    q = p if p.is_absolute() else (root / p)
    if q.exists() and _try_run(q):
        raise SystemExit(0)

# fallback
if safe.exists():
    sys.stderr.write("[Bridge] Falling back to wf_runner_safe.py\n")
    sys.argv[0] = str(safe)
    runpy.run_path(str(safe), run_name="__main__")
else:
    sys.stderr.write(f"[Bridge] SAFE runner missing: {safe}\n")
    sys.exit(3)



